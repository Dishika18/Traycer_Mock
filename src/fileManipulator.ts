import * as vscode from "vscode"
import * as path from "path"
import { type PlanItem, ActionType } from "./types"

export class FileManipulator {
  private readonly backupSuffix = ".traycer-backup"
  private readonly brandName = "Traycer Mock"

  async applyPlanItem(planItem: PlanItem): Promise<void> {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0]
    if (!workspaceFolder) {
      throw new Error("No workspace folder found. Please open a project folder first.")
    }

    const filePath = path.join(workspaceFolder.uri.fsPath, planItem.file)
    const fileUri = vscode.Uri.file(filePath)

    try {
      switch (planItem.action) {
        case ActionType.NEW:
          await this.createNewFile(fileUri, planItem)
          break
        case ActionType.MODIFY:
          await this.modifyFile(fileUri, planItem)
          break
        case ActionType.REMOVE:
          await this.markForRemoval(fileUri, planItem)
          break
        default:
          throw new Error(`Unknown action type: ${planItem.action}`)
      }
    } catch (error) {
      throw new Error(`Failed to apply ${planItem.action} to ${planItem.file}: ${error}`)
    }
  }

  private async createNewFile(fileUri: vscode.Uri, planItem: PlanItem): Promise<void> {
    try {
      await vscode.workspace.fs.stat(fileUri)
      vscode.window.showWarningMessage(`File ${planItem.file} already exists. Adding modification instead.`)
      await this.modifyFile(fileUri, planItem)
      return
    } catch {
    }

    const dirUri = vscode.Uri.file(path.dirname(fileUri.fsPath))
    try {
      await vscode.workspace.fs.createDirectory(dirUri)
    } catch (error) {
    }

    const content = this.generateFileContent(planItem.file, planItem.description)

    await vscode.workspace.fs.writeFile(fileUri, Buffer.from(content, "utf8"))

    try {
      const document = await vscode.workspace.openTextDocument(fileUri)
      await vscode.window.showTextDocument(document, { preview: false })
    } catch (error) {
      console.warn(`Created file ${planItem.file} but couldn't open it: ${error}`)
    }
  }

  private async modifyFile(fileUri: vscode.Uri, planItem: PlanItem): Promise<void> {
    try {
      await this.createBackup(fileUri)

      const document = await vscode.workspace.openTextDocument(fileUri)
      const edit = new vscode.WorkspaceEdit()

      const lastLine = document.lineCount - 1
      const lastLineText = document.lineAt(lastLine).text
      const insertPosition = new vscode.Position(lastLine, lastLineText.length)

      const todoComment = this.generateModificationComment(planItem.file, planItem.description)
      edit.insert(fileUri, insertPosition, todoComment)

      await vscode.workspace.applyEdit(edit)

      await vscode.window.showTextDocument(document, { preview: false })
    } catch (error: unknown) {
      if (error instanceof Error && error.message.includes("Unable to read file")) {
        vscode.window.showInformationMessage(`File ${planItem.file} doesn't exist. Creating new file instead.`)
        await this.createNewFile(fileUri, planItem)
      } else {
        throw error
      }
    }
  }

  private async markForRemoval(fileUri: vscode.Uri, planItem: PlanItem): Promise<void> {
    try {
      await this.createBackup(fileUri)

      const document = await vscode.workspace.openTextDocument(fileUri)
      const edit = new vscode.WorkspaceEdit()

      const insertPosition = new vscode.Position(0, 0)
      const todoComment = this.generateRemovalComment(planItem.file, planItem.description)
      edit.insert(fileUri, insertPosition, todoComment)

      await vscode.workspace.applyEdit(edit)

      await vscode.window.showTextDocument(document, { preview: false })
    } catch (error: unknown) {
      if (error instanceof Error && error.message.includes("Unable to read file")) {
        vscode.window.showWarningMessage(`File ${planItem.file} doesn't exist and cannot be marked for removal.`)
      } else {
        throw error
      }
    }
  }

  private async createBackup(fileUri: vscode.Uri): Promise<void> {
    try {
      const backupUri = vscode.Uri.file(fileUri.fsPath + this.backupSuffix)
      const content = await vscode.workspace.fs.readFile(fileUri)
      await vscode.workspace.fs.writeFile(backupUri, content)
    } catch (error) {
      console.warn(`Failed to create backup for ${fileUri.fsPath}: ${error}`)
    }
  }

  private generateFileContent(filePath: string, description: string): string {
    const fileExtension = path.extname(filePath).toLowerCase()
    const fileName = path.basename(filePath, fileExtension)
    const timestamp = new Date().toISOString()

    const header = `// Generated by ${this.brandName} on ${timestamp}
// TODO: ${description}

`

    switch (fileExtension) {
      case ".tsx":
        return this.generateReactTSXContent(fileName, description, header)
      case ".jsx":
        return this.generateReactJSXContent(fileName, description, header)
      case ".ts":
        return this.generateTypeScriptContent(fileName, description, header)
      case ".js":
        return this.generateJavaScriptContent(fileName, description, header)
      case ".css":
        return this.generateCSSContent(fileName, description)
      case ".scss":
      case ".sass":
        return this.generateSCSSContent(fileName, description)
      case ".json":
        return this.generateJSONContent(description)
      case ".md":
        return this.generateMarkdownContent(fileName, description)
      case ".html":
        return this.generateHTMLContent(fileName, description)
      case ".vue":
        return this.generateVueContent(fileName, description, header)
      case ".py":
        return this.generatePythonContent(fileName, description)
      default:
        return this.generateGenericContent(fileName, description, header)
    }
  }

  private generateReactTSXContent(fileName: string, description: string, header: string): string {
    const componentName = this.toPascalCase(fileName)
    return `${header}import React from 'react'

export const ${componentName}: React.FC<${componentName}Props> = (props) => {
  return (
    <div className="${this.toKebabCase(fileName)}">
      <h1>${componentName}</h1>
      <p>Component implementation needed</p>
      {/* TODO: Implement ${description} */}
    </div>
  )
}

export default ${componentName}
`
  }

  private generateReactJSXContent(fileName: string, description: string, header: string): string {
    const componentName = this.toPascalCase(fileName)
    return `${header}import React from 'react'

export const ${componentName} = (props) => {
  return (
    <div className="${this.toKebabCase(fileName)}">
      <h1>${componentName}</h1>
      <p>Component implementation needed</p>
      {/* TODO: Implement ${description} */}
    </div>
  )
}

export default ${componentName}
`
  }

  private generateTypeScriptContent(fileName: string, description: string, header: string): string {
    const functionName = this.toCamelCase(fileName)
    return `${header}export interface ${this.toPascalCase(fileName)}Config {}

export class ${this.toPascalCase(fileName)} {
  private config: ${this.toPascalCase(fileName)}Config

  constructor(config: ${this.toPascalCase(fileName)}Config) {
    this.config = config
  }

  public ${functionName}(): void {
    throw new Error('Method not implemented')
  }
}

export function ${functionName}(): void {
  throw new Error('Function not implemented')
}
`
  }

  private generateJavaScriptContent(fileName: string, description: string, header: string): string {
    const functionName = this.toCamelCase(fileName)
    return `${header}class ${this.toPascalCase(fileName)} {
  constructor(config = {}) {
    this.config = config
  }

  ${functionName}() {
    throw new Error('Method not implemented')
  }
}

function ${functionName}() {
  throw new Error('Function not implemented')
}

module.exports = {
  ${this.toPascalCase(fileName)},
  ${functionName}
}
`
  }

  private generateCSSContent(fileName: string, description: string): string {
    const className = this.toKebabCase(fileName)
    return `/* Generated by ${this.brandName} */
/* TODO: ${description} */

.${className} {
  display: block;
  position: relative;
}

.${className}__container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 1rem;
}

.${className}__header {
  margin-bottom: 1rem;
}

.${className}__content {
  line-height: 1.6;
}

@media (max-width: 768px) {
  .${className}__container {
    padding: 0.5rem;
  }
}
`
  }

  private generateSCSSContent(fileName: string, description: string): string {
    const className = this.toKebabCase(fileName)
    return `// Generated by ${this.brandName}
// TODO: ${description}

.${className} {
  display: block;
  position: relative;

  &__container {
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    padding: 1rem;

    @media (max-width: 768px) {
      padding: 0.5rem;
    }
  }

  &__header {
    margin-bottom: 1rem;
  }

  &__content {
    line-height: 1.6;
  }
}
`
  }

  private generateJSONContent(description: string): string {
    return `{
  "_comment": "Generated by ${this.brandName}",
  "_todo": "${description}",
  "name": "placeholder",
  "version": "1.0.0",
  "description": "Placeholder configuration file",
  "main": "index.js",
  "scripts": {
    "start": "echo 'TODO: Implement start script'",
    "build": "echo 'TODO: Implement build script'",
    "test": "echo 'TODO: Implement test script'"
  },
  "dependencies": {},
  "devDependencies": {}
}
`
  }

  private generateMarkdownContent(fileName: string, description: string): string {
    const title = this.toTitleCase(fileName)
    return `# ${title}

> Generated by ${this.brandName}

## Overview

TODO: ${description}

## Getting Started

1. TODO: Add setup instructions
2. TODO: Add usage examples
3. TODO: Add configuration details

## Features

- [ ] TODO: Feature 1
- [ ] TODO: Feature 2
- [ ] TODO: Feature 3

## API Reference

TODO: Add API documentation

## Contributing

TODO: Add contribution guidelines

## License

TODO: Add license information
`
  }

  private generateHTMLContent(fileName: string, description: string): string {
    const title = this.toTitleCase(fileName)
    const currentYear = new Date().getFullYear()
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <!-- TODO: ${description} -->
</head>
<body>
    <header>
        <h1>${title}</h1>
    </header>
    
    <main>
        <section>
            <h2>Content</h2>
            <p>TODO: Implement page content</p>
        </section>
    </main>
    
    <footer>
        <p>&copy; ${currentYear} Generated by ${this.brandName}</p>
    </footer>
</body>
</html>
`
  }

  private generateVueContent(fileName: string, description: string, header: string): string {
    const componentName = this.toPascalCase(fileName)
    return `<template>
  <div class="${this.toKebabCase(fileName)}">
    <h1>{{ title }}</h1>
    <p>Component implementation needed</p>
    <!-- TODO: Implement ${description} -->
  </div>
</template>

<script setup lang="ts">
${header}import { ref } from 'vue'

interface Props {}

const props = defineProps<Props>()
const title = ref('${componentName}')
</script>

<style scoped>
.${this.toKebabCase(fileName)} {
  padding: 1rem;
}
</style>
`
  }

  private generatePythonContent(fileName: string, description: string): string {
    const className = this.toPascalCase(fileName)
    const functionName = this.toSnakeCase(fileName)
    return `"""
Generated by ${this.brandName}
TODO: ${description}
"""

from typing import Any, Dict, List, Optional


class ${className}:
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
    
    def ${functionName}(self) -> None:
        raise NotImplementedError("Method not implemented")


def ${functionName}() -> None:
    raise NotImplementedError("Function not implemented")


if __name__ == "__main__":
    print("TODO: Implement main functionality")
`
  }

  private generateGenericContent(fileName: string, description: string, header: string): string {
    return `${header}
File: ${fileName}
Description: ${description}

TODO: Implement file content based on the description above.

This is a placeholder file generated by ${this.brandName}.
Please replace this content with the actual implementation.
`
  }

  private generateModificationComment(filePath: string, description: string): string {
    const fileExtension = path.extname(filePath).toLowerCase()
    const timestamp = new Date().toISOString()

    if ([".css", ".scss", ".sass"].includes(fileExtension)) {
      return `

/* ===== ${this.brandName.toUpperCase()} MODIFICATION (${timestamp}) ===== */
/* TODO: modify file for ${description} */
/* ================================================== */`
    }

    if (fileExtension === ".html") {
      return `

<!-- ===== ${this.brandName.toUpperCase()} MODIFICATION (${timestamp}) ===== -->
<!-- TODO: modify file for ${description} -->
<!-- ================================================== -->`
    }

    if (fileExtension === ".py") {
      return `

# ===== ${this.brandName.toUpperCase()} MODIFICATION (${timestamp}) =====
# TODO: modify file for ${description}
# ==================================================`
    }

    return `

// ===== ${this.brandName.toUpperCase()} MODIFICATION (${timestamp}) =====
// TODO: modify file for ${description}
// ==================================================`
  }

  private generateRemovalComment(filePath: string, description: string): string {
    const fileExtension = path.extname(filePath).toLowerCase()
    const timestamp = new Date().toISOString()

    if ([".css", ".scss", ".sass"].includes(fileExtension)) {
      return `/* ===== ${this.brandName.toUpperCase()} - MARKED FOR REMOVAL (${timestamp}) ===== */
/* TODO: remove this file - ${description} */
/* ========================================================== */

`
    }

    if (fileExtension === ".html") {
      return `<!-- ===== ${this.brandName.toUpperCase()} - MARKED FOR REMOVAL (${timestamp}) ===== -->
<!-- TODO: remove this file - ${description} -->
<!-- ========================================================== -->

`
    }

    if (fileExtension === ".py") {
      return `# ===== ${this.brandName.toUpperCase()} - MARKED FOR REMOVAL (${timestamp}) =====
# TODO: remove this file - ${description}
# ==========================================================

`
    }

    return `// ===== ${this.brandName.toUpperCase()} - MARKED FOR REMOVAL (${timestamp}) =====
// TODO: remove this file - ${description}
// ==========================================================

`
  }

  private toPascalCase(str: string): string {
    return str
      .replace(/[-_\s]+(.)?/g, (_, char) => (char ? char.toUpperCase() : ""))
      .replace(/^(.)/, (char) => char.toUpperCase())
  }

  private toCamelCase(str: string): string {
    const pascal = this.toPascalCase(str)
    return pascal.charAt(0).toLowerCase() + pascal.slice(1)
  }

  private toKebabCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, "$1-$2")
      .replace(/[\s_]+/g, "-")
      .toLowerCase()
  }

  private toSnakeCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, "$1_$2")
      .replace(/[\s-]+/g, "_")
      .toLowerCase()
  }

  private toTitleCase(str: string): string {
    return str.replace(/[-_]/g, " ").replace(/\b\w/g, (char) => char.toUpperCase())
  }
}